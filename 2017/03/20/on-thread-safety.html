<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>On Thread Safety</title>
  <meta name="description" content="# AUDIENCE">

  <link rel="stylesheet" href="/blog/assets/main.css">
  <link rel="canonical" href="https://agenttroll.github.io/blog/2017/03/20/on-thread-safety.html">
  <link rel="alternate" type="application/rss+xml" title="Inside a Troll" href="/blog/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/blog/">Inside a Troll</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/blog/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">On Thread Safety</h1>
    <p class="post-meta">
      <time datetime="2017-03-20T18:21:17-07:00" itemprop="datePublished">
        
        Mar 20, 2017
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a name="audience"></a></p>
<h1 id="-audience"><a href="#audience">#</a> AUDIENCE</h1>

<p>While I attempt to do my best to explain as many of the concepts as possible in layman terms, it may become very difficult to follow along with what I say if you have no prior programming experience. I recommend being a proficient programmer before reading this.</p>

<p>I have also specifically targeted this post to Java. Whether or not what I say applies to other languages or concepts, I do not care nor do I intend to make those connections.</p>

<p>I go from the very basics to some quite high-level topics in this post. If you are a professional dev who has worked in the industry for decades and already know how to write thread-safe code, good for you. I do not intend the beginning few sections to be targeted for you. If you are a beginner, you might find some of the concepts difficult to comprehend. That’s OK. If you need a break, go ahead and take one and let the information you’ve learned sink in.</p>

<p>Finally, I really do try to my best of my ability to avoid making erreneous or overly biased, opininated claims. However, I am a human. I make mistakes. I have opinions. I am not responsible for your losses due to you using what I write to write your own code. Your code is your responsibility. My opinions do not represent those who I am associated with whether they be my (currently nonexistant) employer, my friends, etc. They are my own opinions only. I do not portray myself as superior in skill, age, or whatever in anyway to the reader. If you interpret what I write as so, feel free to stop reading and be a dick to me in retaliation (or politely call me out).</p>

<p>With that said, I do hope that you will learn something out of reading what I have written.</p>

<hr />

<p><a name="introduction"></a></p>
<h1 id="-introduction"><a href="#introduction">#</a> INTRODUCTION</h1>

<ul>
  <li>Asynchronous</li>
  <li>Multithreaded</li>
  <li>Scalable</li>
  <li>Parallel</li>
  <li>Concurrent</li>
</ul>

<p>Heard of these words before?</p>

<p>In case you’ve been living under a rock for over a (few) decade(s), or you are not a programmer, these are quite important concepts to understand in the modern world of computing. Parallelization is absolutely one of the most important ways that computers have become more and more powerful over the years, and the time has come for people to understand how to build software that truly takes advantage of parallelism rather than processor clock speeds.</p>

<blockquote>
  <p>serial programs run on modern computers “waste” potential computing power.</p>
</blockquote>

<blockquote>
  <p>During the past 20+ years, the trends indicated by ever faster networks, distributed systems, and multi-processor computer architectures (even at the desktop level) clearly show that parallelism is the future of computing.</p>
</blockquote>

<p>(<a href="https://computing.llnl.gov/tutorials/parallel_comp/#WhyUse">Introduction to Parallel Computing, Lawrence Livermore National Labratory</a>)</p>

<blockquote>
  <p>This changeover [from favoring high clock speeds to favoring multicore processors instead] had a profound impact on software performance. Previously, faster hardware speeds translated directly into faster software computation. Afterwards, only software that could take advantage of multiple processors would get this benefit – and not all of them could</p>
</blockquote>

<p>(<a href="http://funginstitute.berkeley.edu/wp-content/uploads/2013/12/Neil_Thompson-27s_Moore-27s_Law_Paper_-_Summary.pdf">Moore’s Law Goes Multicore, Berkeley Haas School of Business</a>)</p>

<p>It turns out that the benefit that comes from exploiting multiprocessors is a double-edged blade. We find that there is a <em>minor</em> difficulty with developing software that is capable of multithreading, that is, ensuring that these applications are <strong>thread-safe</strong>.</p>

<p>Before beginning, it is worth mentioning that multithreading is an extremely difficult topic to organize and talk about. Ideas jump all over the place and there are many different things that all contribute to fully understanding one big thing. I had the same experience when I was first learning about multithreading, and what I found helped me was to keep going through, because often as I learn a bit more about different topics, I strengthen my understanding of topics that I previous didn’t understand fully. Take some time to digest and comprehend the ideas once you’ve finished rather than attempting to piece everything together as you go along.</p>

<hr />

<p><a name="what-is-thread-safety"></a></p>
<h1 id="-what-is-thread-safety"><a href="#what-is-thread-safety">#</a> WHAT IS THREAD-SAFETY?</h1>

<p>Thread-safety is a problem arising from when program state is shared between threads.</p>

<blockquote>
  <p><strong>State</strong>: state refers to variables, basically as a general term to describe anything that holds a value. Fields, global variables, and others are considered to be part of the “program state,” or the various different values that need to be passed around and set in a program.</p>
</blockquote>

<p>The concept of a “shared state,” or state that is accessible and modifiable (mutable) by many threads is the root of thread-safety problems. A thread-safe program therefore eliminates the problems introduced by accessing that shared state from different threads.</p>

<p>If your program is not thread-safe, insidious and perhaps even catastrophic bugs can arise. Thread-safety issues are difficult to understand because the result of certain operations are counterintuitive on initial inspection.</p>

<h4 id="visibility-issues">Visibility Issues</h4>

<p>Consider the following sequence of events from two threads that are reading and mutating the same shared state:</p>

<p><img src="https://agenttroll.github.io/blog/img/Visibility.jpg" alt="Visbility" /></p>

<p>In the absence of adequate synchronization, the above diagram demonstrates how <code class="highlighter-rouge">Thread 1</code> continues to read <code class="highlighter-rouge">4</code> from a shared state, even after <code class="highlighter-rouge">Thread 2</code> has set it to <code class="highlighter-rouge">5</code>. The value read by <code class="highlighter-rouge">Thread 1</code> might have been cached. Another possibility is that the new value set by <code class="highlighter-rouge">Thread 2</code> might have been cached where only <code class="highlighter-rouge">Thread 2</code> can see it, and therefore <code class="highlighter-rouge">Thread 1</code> continues to read the value from memory when it should be reading from <code class="highlighter-rouge">Thread 2</code>’s cache instead. This is a visibility issue because without the necessary synchronization, it is possible that threads simply don’t even see changes made to a shared state.</p>

<h4 id="ordering-issues">Ordering Issues</h4>

<p>Consider the following snippet of code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NotThreadSafe</span>
<span class="kd">class</span> <span class="nc">MutableState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">()</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">++;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="n">MutableState</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MutableState</span><span class="o">();</span>
<span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">state</span><span class="o">.</span><span class="na">mutate</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">read</span><span class="o">());</span>
<span class="o">});</span>
<span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">state</span><span class="o">.</span><span class="na">mutate</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">read</span><span class="o">());</span>
<span class="o">});</span>
<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>In the absence of synchronization to dictate the execution order between threads, there are no guarantees about who or even what runs first. It is entirely possible for <code class="highlighter-rouge">t1</code> to start AFTER <code class="highlighter-rouge">t2</code>. It is also possible for <code class="highlighter-rouge">t1</code> to run as expected before <code class="highlighter-rouge">t2</code>, but there are no guarantees here. It is even possible for <code class="highlighter-rouge">t1</code> to <code class="highlighter-rouge">state.mutate()</code> <em>simultaneously</em> with <code class="highlighter-rouge">t2</code>. Referring back to our visibility example, it is possible for <code class="highlighter-rouge">t2</code> to not even see what changes have been made by <code class="highlighter-rouge">t1</code>.</p>

<p>This time diagram shows an entirely possible execution ordering between the two threads:</p>

<p><img src="https://agenttroll.github.io/blog/img/ots-race-condition.svg" alt="Race Condition Time Diagram" /></p>

<p>And the output for the two threads are then as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
2
</code></pre></div></div>

<p>What is often difficult for novice developers to think about is potential for operations to occur out of order. In the above diagram, although <code class="highlighter-rouge">t1</code> was <code class="highlighter-rouge">start</code>ed first, the scheduler might actually begin execiting <code class="highlighter-rouge">t2</code> before anything even starts in <code class="highlighter-rouge">t1</code>. This is an ordering issue because threads are not run in an expected order.</p>

<h4 id="atomicity-issues">Atomicity Issues</h4>

<p>Atomic, from the Greek word <em>atomos</em> meaning “indivisible” refers to a property of an operation whereby it will execute in its entirety (or not execute at all) without being interrupted by another operation.</p>

<p>A common way to illustrate an atomicity issue is through the <code class="highlighter-rouge">++</code> operator. A <code class="highlighter-rouge">++</code> can be mistakenly seen as an atomic operation because it only takes up one line, however, that is not actually true. A <code class="highlighter-rouge">++</code> clumps together 3 operations:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
<span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span>
</code></pre></div></div>

<p>Which means that it is possible for a different thread that increments the same state to interrupt the increment operation of another thread.</p>

<p>If we waited for 2 threads increment the state once, then we would expect the <code class="highlighter-rouge">main</code> thread to print out <code class="highlighter-rouge">2</code> in the end. However, because the <code class="highlighter-rouge">++</code> operation isn’t atomic, the following scenario might occur:</p>

<p><img src="https://agenttroll.github.io/blog/img/ots-race-condition-2.svg" alt="Race Condition Time Diagram 2" /></p>

<p>In this case, the output may well be <code class="highlighter-rouge">1</code>, but that doesn’t even consider visibility issues. Factoring in visibility issues, you might even print out a <code class="highlighter-rouge">0</code> because the <code class="highlighter-rouge">main</code> thread reads the initial value of the state from its cache.</p>

<hr />

<p><a name="what-causes-threads-to-behave-this-way"></a></p>
<h1 id="-what-causes-threads-to-behave-this-way"><a href="#what-causes-threads-to-behave-this-way">#</a> WHAT CAUSES THREADS TO BEHAVE THIS WAY?</h1>

<p>Having some basic idea of what “thread-safety” is and the problems caused by programs that are not thread-safe, I believe that there is benefit in discussing the nitty gritty details of why threads behave in this “independent” manner. There tends to be a lot of widespread use of mere analogies in order to explain why thread-safety is a problem and this in itself has caused issues on its own.</p>

<p>Going along the same vein as with the “messy details” of multithreading, now is a good time to also discuss some drawbacks of writing multithreaded programs:</p>

<ul>
  <li>They are difficult to write correctly</li>
  <li>They are difficult to test for correctness</li>
  <li>They are difficult to test for performance</li>
  <li>They are difficult to understand multithreaded code</li>
  <li>It is difficult to distribute work and tasks amongst threads</li>
  <li>It is difficult to do resource management - deadlocks, livelocks, starvation</li>
  <li>Coercing system resources to initialize a thread is relatively expensive</li>
  <li>Locking, memory barriers, mutexes and other synchronization primitives add housekeeping overhead</li>
  <li>Ordering and fencing memory access are not free</li>
  <li>Distributing processor time by the thread scheduler comes with overhead</li>
  <li>They sometimes cause degredation in performance due to poor implementaiton</li>
  <li>They are prone to interfering with other threads or other programs</li>
</ul>

<p>Multithreading isn’t a magic sauce you can simply add to make your program run faster. It requires a ground-up design approach, a careful analysis of cost-benefit, as well as an actual evaluation of the possible performance gain you can get out of multithreading. As discussed before, the costs associated with multithreading derives from the fact that they act independently. As Java Concurrency in Practice puts it, threads are like mini-programs. Your internet browser isn’t going to care about what your terminal is doing as they are both independent programs. Like programs, threads, by default, don’t care about what other threads are up to either.</p>

<p>A thread will intrinsically behave as if it were the only thread running on the entire system because this is the most useful and performant default <em>most</em> of the time. Many Java programs are relatively simple and require only one thread to run the <code class="highlighter-rouge">main(String[] args)</code> method.</p>

<blockquote>
  <p>It is worth nothing that essentially no Java programs are actually “single-threaded” in the strictest sense of the word. The JVM always runs a few threads to perform GC, JIT optimizations, perhaps RMI and Ctrl-Break monitoring as well depending on the environment. A Java program is usually only referred to as “multithreaded” only if the program code itself is actually creating new threads.</p>
</blockquote>

<p>This “single-threaded universe” assumption allows for many possible optimizations such as thread-local caching. Since the default is to behave as if other threads don’t exist, a thread might cache state values recently read or mutated. Because the caching thread thinks that it is the only thread in existence, it won’t consider looking at the caches of other threads, and other threads won’t do look at the caching thread either because they have their own caches as well. Threads will continue to read and modify their own cached state variables, which leads to visibility issues. By default, The CPU assumes that its caches are the “source of truth,” meaning that if a value from main memory (or RAM) is cached in its multi-level caches, then the CPU will consider the cached value as correct, even if the value in main memory could have been updated by a different thread.</p>

<p>In order to understand why caching is necessary, it may be helpful to look at a diagram of a typical Intel CPU in relation to main memory:</p>

<p><img src="https://agenttroll.github.io/blog/img/CPU.jpg" alt="CPU" /></p>

<p>The primary reason why caching is necessary is because lookups to main memory (or the memory stored in RAM) is several orders of a magnitude slower than lookups to something like a multi-level cache (L1/L2/L3). DRAM memory is slow because it is usually quite large and quite far away from the CPU. On the thread-level, state variables may be cached in either the registers or the multi-level caches, which are both small and localized close to the execution cores, meaning that lookups take significantly less time to transmit data to the execution core. Additionally, SRAM memory used in caches is physically much faster than DRAM memory used for main memory. More SRAM memory isn’t used because it is literally expensive as fuck, it costs $5000 USD for a single gigabyte (&gt;100 times the cost per gigabyte of DRAM) and increasing the physical size of the memory storage would also increase the lookup time simply because data travel time increases.</p>

<p>By now, you’ve seen me write “(shared) state” quite a few times. As was mentioned in the previous section, it is important to note that the entire reason why thread-safety issues even exist is due to <em>shared states</em>. <strong>In the absence of shared states, even multithreaded programs are guaranteed to be thread-safe</strong>. If you are NOT sharing data between threads, or if there are no other threads to even share data with, no inconsistencies can be seen.</p>

<p>Because inevitably, a programmer would need to share data in some form or another in their multithreaded programs, CPUs must have a way to ensure that the caches between each execution unit remain coherent. There must be some way for shared states to update their value across caches, and for threads to retrieve values that might have been changed. Many people refer to ensuring shared states are up to date by talking about “cache flushes,” whereby the cached state is flushed back to main memory. However, this doesn’t make any sense; not only do CPUs not use main memory as a source of truth, it would also make synchronization basically prohibitively expensive because the data would need to cross the memory bus to get back into main memory. Instead, caches are usually kept coherent by policy, meaning that CPUs utilize various protocols (such as the MESIF and MOESI varients of the MESI protocol) that ensure that cached values are kept consistent.</p>

<p>I won’t get into the nitty gritty details of how the protocols themselves work, all you need to know is that they work. The more important point is that even with cache coherency protocols in place, inadequately synchronized code may still not work correctly. Execution cores use buffers to store read/write instructions that are sent through the cache coherence protocol. CPUs may be able to use <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/pipelining/">pipelining</a> to keep running instructions as they wait for load requests, for example. In some cases, a CPU may read a “store” instruction from its buffer even though a different value has been stored later on, and would therefore read a stale value. This means that we are still having the visibility problem even with the implementation of cache coherency.</p>

<p>Luckily, CPUs provide <em>fencing instructions</em> that insert a “barrier” in the buffer. This means that the entire buffer needs to be processed before execution can proceed, so values that are waiting to be updated are actually updated prior to whatever the thread needs to do. This ensures that the execution core reads the most up-to-date value from another cache or from main-memory.</p>

<p>The Java language provides a memory model which simplifies these details into various different tools and constructs such as the <code class="highlighter-rouge">volatile</code> and <code class="highlighter-rouge">synchronized</code> keywords. It is not necessary to understand all the technical details of what a CPU ends up doing to write thread-safe code. However, by having a little bit more background on what the hardware is doing, programmers can understand the need for adequate synchronization and the significance of ensuring that multithreaded code is safe to run.</p>

<p>Sources used:</p>

<ul>
  <li><a href="https://mechanical-sympathy.blogspot.com/2013/02/cpu-cache-flushing-fallacy.html">CPU Cache Flushing Fallacy, Mechanical Sympathy</a></li>
  <li><a href="https://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html">Memory Barriers/Fences, Mechanical Sympathy</a></li>
  <li><a href="http://www.javamex.com/tutorials/threads/thread_scheduling_java.shtml">Thread scheduling implications in Java, Javamex</a></li>
  <li><a href="http://www.javamex.com/tutorials/threads/context_switch.shtml">Context and process switching, Javamex</a></li>
  <li><a href="https://www.cs.cmu.edu/~fp/courses/15213-s06/lectures/27-multicore.pdf">Multi-core architectures, Carnegie Mellon University</a></li>
  <li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/10_coherence.pdf">Lecture 10: Cache Coherence: Part I, Carnegie Mellon University</a></li>
  <li><a href="https://www.scss.tcd.ie/Jeremy.Jones/vivio/caches/MESIHelp.htm">MESI Cache Coherency Protocol, Trinity College Dublin, the University of Dublin, Ireland</a></li>
  <li><a href="http://web.cecs.pdx.edu/~alaa/ece587/notes/memory-ordering.pdf">Memory Ordering, Portland State University</a></li>
</ul>

<hr />

<p><a name="how-to-write-thread-safe-code"></a></p>
<h1 id="-how-to-write-thread-safe-code"><a href="#how-to-write-thread-safe-code">#</a> HOW TO WRITE THREAD-SAFE CODE?</h1>

<p>As previously discussed, the Java language offers many tools to help simplify the process of writing thread-safe code without needing to understand all the hardware details.</p>

<p><code class="highlighter-rouge">// TODO</code></p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Inside a Troll</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Inside a Troll
            
            </li>
            
            <li><a href="mailto:woodyc40@gmail.com">woodyc40@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/AgentTroll"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">AgentTroll</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/AgentTrolldude"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">AgentTrolldude</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Thoughts of a Java developer</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
