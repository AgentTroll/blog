<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>On Thread Safety</title>
  <meta name="description" content="# AUDIENCE">

  <link rel="stylesheet" href="/blog/assets/main.css">
  <link rel="canonical" href="https://agenttroll.github.io/blog/2017/03/20/on-thread-safety.html">
  <link rel="alternate" type="application/rss+xml" title="Inside a Troll" href="/blog/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/blog/">Inside a Troll</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/blog/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">On Thread Safety</h1>
    <p class="post-meta">
      <time datetime="2017-03-20T18:21:17-07:00" itemprop="datePublished">
        
        Mar 20, 2017
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a name="audience"></a></p>
<h1 id="-audience"><a href="#audience">#</a> AUDIENCE</h1>

<p>While I attempt to do my best to explain as many of the concepts as possible in layman terms, it may become very difficult to follow along with what I say if you have no prior programming experience. I recommend being a proficient programmer before reading this.</p>

<p>I have also specifically targeted this post to Java. Whether or not what I say applies to other languages or concepts, I do not care nor do I intend to make those connections.</p>

<p>I go from the very basics to some quite high-level topics in this post. If you are a professional dev who has worked in the industry for decades and already know how to write thread-safe code, good for you. I do not intend the beginning few sections to be targeted for you. If you are a beginner, you might find some of the concepts difficult to comprehend. That’s OK. If you need a break, go ahead and take one and let the information you’ve learned sink in.</p>

<p>Finally, I really do try to my best of my ability to avoid making erreneous or overly biased, opininated claims. However, I am a human. I make mistakes. I have opinions. I am not responsible for your losses due to you using what I write to write your own code. Your code is your responsibility. My opinions do not represent those who I am associated with whether they be my (currently nonexistant) employer, my friends, etc. They are my own opinions only. I do not portray myself as superior in skill, age, or whatever in anyway to the reader. If you interpret what I write as so, feel free to stop reading and be a dick to me in retaliation (or politely call me out).</p>

<p>With that said, I do hope that you will learn something out of reading what I have written.</p>

<hr />

<p><a name="introduction"></a></p>
<h1 id="-introduction"><a href="#introduction">#</a> INTRODUCTION</h1>

<ul>
  <li>Asynchronous</li>
  <li>Multithreaded</li>
  <li>Scalable</li>
  <li>Parallel</li>
  <li>Concurrent</li>
</ul>

<p>Heard of these words before?</p>

<p>In case you’ve been living under a rock for over a (few) decade(s), or you are not a programmer, these are quite important concepts to understand in the modern world of computing. Parallelization is absolutely one of the most important ways that computers have become more and more powerful over the years, and the time has come for people to understand how to build software that truly takes advantage of parallelism rather than processor clock speeds.</p>

<blockquote>
  <p>serial programs run on modern computers “waste” potential computing power.</p>
</blockquote>

<blockquote>
  <p>During the past 20+ years, the trends indicated by ever faster networks, distributed systems, and multi-processor computer architectures (even at the desktop level) clearly show that parallelism is the future of computing.</p>
</blockquote>

<p>(<a href="https://computing.llnl.gov/tutorials/parallel_comp/#WhyUse">Introduction to Parallel Computing, Lawrence Livermore National Labratory</a>)</p>

<blockquote>
  <p>This changeover [from favoring high clock speeds to favoring multicore processors instead] had a profound impact on software performance. Previously, faster hardware speeds translated directly into faster software computation. Afterwards, only software that could take advantage of multiple processors would get this benefit – and not all of them could</p>
</blockquote>

<p>(<a href="http://funginstitute.berkeley.edu/wp-content/uploads/2013/12/Neil_Thompson-27s_Moore-27s_Law_Paper_-_Summary.pdf">Moore’s Law Goes Multicore, Berkeley Haas School of Business</a>)</p>

<p>It turns out that the benefit that comes from exploiting multiprocessors is a double-edged blade. We find that there is a <em>minor</em> difficulty with developing software that is capable of multithreading, that is, ensuring that these applications are <strong>thread-safe</strong>.</p>

<p>Before beginning, it is worth mentioning that multithreading is an extremely difficult topic to organize and talk about. Ideas jump all over the place and there are many different things that all contribute to fully understanding one big thing. I had the same experience when I was first learning about multithreading, and what I found helped me was to keep going through, because often as I learn a bit more about different topics, I strengthen my understanding of topics that I previous didn’t understand fully. Take some time to digest and comprehend the ideas once you’ve finished rather than attempting to piece everything together as you go along.</p>

<hr />

<p><a name="what-is-thread-safety"></a></p>
<h1 id="-what-is-thread-safety"><a href="#what-is-thread-safety">#</a> WHAT IS THREAD-SAFETY?</h1>

<p>Thread-safety is a problem arising from when program state is shared between threads.</p>

<blockquote>
  <p><strong>State</strong>: state refers to variables, basically as a general term to describe anything that holds a value. Fields, global variables, and others are considered to be part of the “program state,” or the various different values that need to be passed around and set in a program.</p>
</blockquote>

<p>The concept of a “shared state,” or state that is accessible and modifiable (mutable) by many threads is the root of thread-safety problems. A thread-safe program therefore eliminates the problems introduced by accessing that shared state from different threads.</p>

<p>If your program is not thread-safe, insidious and perhaps even catastrophic bugs can arise. Thread-safety issues are difficult to understand because the result of certain operations are counterintuitive on initial inspection.</p>

<h4 id="visibility-issues">Visibility Issues</h4>

<p>Consider the following sequence of events from two threads that are reading and mutating the same shared state:</p>

<p><img src="https://agenttroll.github.io/blog/img/Visibility.jpg" alt="Visbility" /></p>

<p>In the absence of adequate synchronization, the above diagram demonstrates how <code class="highlighter-rouge">Thread 1</code> continues to read <code class="highlighter-rouge">4</code> from a shared state, even after <code class="highlighter-rouge">Thread 2</code> has set it to <code class="highlighter-rouge">5</code>. The value read by <code class="highlighter-rouge">Thread 1</code> might have been cached. Another possibility is that the new value set by <code class="highlighter-rouge">Thread 2</code> might have been cached where only <code class="highlighter-rouge">Thread 2</code> can see it, and therefore <code class="highlighter-rouge">Thread 1</code> continues to read the value from memory when it should be reading from <code class="highlighter-rouge">Thread 2</code>’s cache instead. This is a visibility issue because without the necessary synchronization, it is possible that threads simply don’t even see changes made to a shared state.</p>

<h4 id="ordering-issues">Ordering Issues</h4>

<p>Consider the following snippet of code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NotThreadSafe</span>
<span class="kd">class</span> <span class="nc">MutableState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">()</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">++;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="n">MutableState</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MutableState</span><span class="o">();</span>
<span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">state</span><span class="o">.</span><span class="na">mutate</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">read</span><span class="o">());</span>
<span class="o">});</span>
<span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">state</span><span class="o">.</span><span class="na">mutate</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">read</span><span class="o">());</span>
<span class="o">});</span>
<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>In the absence of synchronization to dictate the execution order between threads, there are no guarantees about who or even what runs first. It is entirely possible for <code class="highlighter-rouge">t1</code> to start AFTER <code class="highlighter-rouge">t2</code>. It is also possible for <code class="highlighter-rouge">t1</code> to run as expected before <code class="highlighter-rouge">t2</code>, but there are no guarantees here. It is even possible for <code class="highlighter-rouge">t1</code> to <code class="highlighter-rouge">state.mutate()</code> <em>simultaneously</em> with <code class="highlighter-rouge">t2</code>. Referring back to our visibility example, it is possible for <code class="highlighter-rouge">t2</code> to not even see what changes have been made by <code class="highlighter-rouge">t1</code>.</p>

<p>This time diagram shows an entirely possible execution ordering between the two threads:</p>

<p><img src="https://agenttroll.github.io/blog/img/ots-race-condition.svg" alt="Race Condition Time Diagram" /></p>

<p>And the output for the two threads are then as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
2
</code></pre></div></div>

<p>What is often difficult for novice developers to think about is potential for operations to occur out of order. In the above diagram, although <code class="highlighter-rouge">t1</code> was <code class="highlighter-rouge">start</code>ed first, the scheduler might actually begin execiting <code class="highlighter-rouge">t2</code> before anything even starts in <code class="highlighter-rouge">t1</code>. This is an ordering issue because threads are not run in an expected order.</p>

<h4 id="atomicity-issues">Atomicity Issues</h4>

<p>Atomic, from the Greek word <em>atomos</em> meaning “indivisible” refers to a property of an operation whereby it will execute in its entirety (or not execute at all) without being interrupted by another operation.</p>

<p>A common way to illustrate an atomicity issue is through the <code class="highlighter-rouge">++</code> operator. A <code class="highlighter-rouge">++</code> can be mistakenly seen as an atomic operation because it only takes up one line, however, that is not actually true. A <code class="highlighter-rouge">++</code> clumps together 3 operations:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
<span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span>
</code></pre></div></div>

<p>Which means that it is possible for a different thread that increments the same state to interrupt the increment operation of another thread.</p>

<p>If we waited for 2 threads increment the state once, then we would expect the <code class="highlighter-rouge">main</code> thread to print out <code class="highlighter-rouge">2</code> in the end. However, because the <code class="highlighter-rouge">++</code> operation isn’t atomic, the following scenario might occur:</p>

<p><img src="https://agenttroll.github.io/blog/img/ots-race-condition-2.svg" alt="Race Condition Time Diagram 2" /></p>

<p>In this case, the output may well be <code class="highlighter-rouge">1</code>, but that doesn’t even consider visibility issues. Factoring in visibility issues, you might even print out a <code class="highlighter-rouge">0</code> because the <code class="highlighter-rouge">main</code> thread reads the initial value of the state from its cache.</p>

<hr />

<p><a name="what-causes-threads-to-behave-this-way"></a></p>
<h1 id="-what-causes-threads-to-behave-this-way"><a href="#what-causes-threads-to-behave-this-way">#</a> WHAT CAUSES THREADS TO BEHAVE THIS WAY?</h1>

<p>Having some basic idea of what “thread-safety” is and the problems caused by programs that are not thread-safe, I believe that there is benefit in discussing the nitty gritty details of why threads behave in this “independent” manner. There tends to be a lot of widespread use of mere analogies in order to explain why thread-safety is a problem and this in itself has caused issues on its own.</p>

<p>Going along the same vein as with the “messy details” of multithreading, now is a good time to also discuss some drawbacks of writing multithreaded programs:</p>

<ul>
  <li>They are difficult to write correctly</li>
  <li>They are difficult to test for correctness</li>
  <li>They are difficult to test for performance</li>
  <li>They are difficult to understand multithreaded code</li>
  <li>It is difficult to distribute work and tasks amongst threads</li>
  <li>It is difficult to do resource management - deadlocks, livelocks, starvation</li>
  <li>Coercing system resources to initialize a thread is relatively expensive</li>
  <li>Locking, memory barriers, mutexes and other synchronization primitives add housekeeping overhead</li>
  <li>Ordering and fencing memory access are not free</li>
  <li>Distributing processor time by the thread scheduler comes with overhead</li>
  <li>They sometimes cause degredation in performance due to poor implementaiton</li>
  <li>They are prone to interfering with other threads or other programs</li>
</ul>

<p>Multithreading isn’t a magic sauce you can simply add to make your program run faster. It requires a ground-up design approach, a careful analysis of cost-benefit, as well as an actual evaluation of the possible performance gain you can get out of multithreading. As discussed before, the costs associated with multithreading derives from the fact that they act independently. As Java Concurrency in Practice puts it, threads are like mini-programs. Your internet browser isn’t going to care about what your terminal is doing as they are both independent programs. Like programs, threads, by default, don’t care about what other threads are up to either.</p>

<p>A thread will intrinsically behave as if it were the only thread running on the entire system because this is the most useful and performant default <em>most</em> of the time. Many Java programs are relatively simple and require only one thread to run the <code class="highlighter-rouge">main(String[] args)</code> method.</p>

<blockquote>
  <p>It is worth nothing that essentially no Java programs are actually “single-threaded” in the strictest sense of the word. The JVM always runs a few threads to perform GC, JIT optimizations, perhaps RMI and Ctrl-Break monitoring as well depending on the environment. A Java program is usually only referred to as “multithreaded” only if the program code itself is actually creating new threads.</p>
</blockquote>

<p>This “single-threaded universe” assumption allows for many possible optimizations such as thread-local caching. Since the default is to behave as if other threads don’t exist, a thread might cache state values recently read or mutated. Because the caching thread thinks that it is the only thread in existence, it won’t consider looking at the caches of other threads, and other threads won’t do look at the caching thread either because they have their own caches as well. Threads will continue to read and modify their own cached state variables, which leads to visibility issues. By default, The CPU assumes that its caches are the “source of truth,” meaning that if a value from main memory (or RAM) is cached in its multi-level caches, then the CPU will consider the cached value as correct, even if the value in main memory could have been updated by a different thread.</p>

<p>In order to understand why caching is necessary, it may be helpful to look at a diagram of a typical Intel CPU in relation to main memory:</p>

<p><img src="https://agenttroll.github.io/blog/img/CPU.jpg" alt="CPU" /></p>

<p>The primary reason why caching is necessary is because lookups to main memory (or the memory stored in RAM) is several orders of a magnitude slower than lookups to something like a multi-level cache (L1/L2/L3). DRAM memory is slow because it is usually quite large and quite far away from the CPU. On the thread-level, state variables may be cached in either the registers or the multi-level caches, which are both small and localized close to the execution cores, meaning that lookups take significantly less time to transmit data to the execution core. Additionally, SRAM memory used in caches is physically much faster than DRAM memory used for main memory. More SRAM memory isn’t used because it is literally expensive as fuck, it costs $5000 USD for a single gigabyte (&gt;100 times the cost per gigabyte of DRAM) and increasing the physical size of the memory storage would also increase the lookup time simply because data travel time increases.</p>

<p>By now, you’ve seen me write “(shared) state” quite a few times. As was mentioned in the previous section, it is important to note that the entire reason why thread-safety issues even exist is due to <em>shared states</em>. <strong>In the absence of shared states, even multithreaded programs are guaranteed to be thread-safe</strong>. If you are NOT sharing data between threads, or if there are no other threads to even share data with, no inconsistencies can be seen.</p>

<p>Because inevitably, a programmer would need to share data in some form or another in their multithreaded programs, CPUs must have a way to ensure that the caches between each execution unit remain coherent. There must be some way for shared states to update their value across caches, and for threads to retrieve values that might have been changed. Many people refer to ensuring shared states are up to date by talking about “cache flushes,” whereby the cached state is flushed back to main memory. However, this doesn’t make any sense; not only do CPUs not use main memory as a source of truth, it would also make synchronization basically prohibitively expensive because the data would need to cross the memory bus to get back into main memory. Instead, caches are usually kept coherent by policy, meaning that CPUs utilize various protocols (such as the MESIF and MOESI varients of the MESI protocol) that ensure that cached values are kept consistent.</p>

<p>I won’t get into the nitty gritty details of how the protocols themselves work, all you need to know is that they work. The more important point is that even with cache coherency protocols in place, inadequately synchronized code may still not work correctly. Execution cores use buffers to store read/write instructions that are sent through the cache coherence protocol. CPUs may be able to use <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/pipelining/">pipelining</a> to keep running instructions as they wait for load requests, for example. In some cases, a CPU may read a “store” instruction from its buffer even though a different value has been stored later on, and would therefore read a stale value. This means that we are still having the visibility problem even with the implementation of cache coherency.</p>

<p>Luckily, CPUs provide <em>fencing instructions</em> that insert a “barrier” in the buffer. This means that the contents of buffer up to the point where the fence is inserted needs to be processed before execution can proceed, so values that are waiting to be updated are actually updated prior to whatever the thread needs to do. This ensures that the execution core reads the most up-to-date value from another cache or from main-memory.</p>

<p>The Java language provides a memory model which simplifies these details into various different tools and constructs such as the <code class="highlighter-rouge">volatile</code> and <code class="highlighter-rouge">synchronized</code> keywords. It is not necessary to understand all the technical details of what a CPU ends up doing to write thread-safe code. However, by having a little bit more background on what the hardware is doing, programmers can understand the need for adequate synchronization and the significance of ensuring that multithreaded code is safe to run.</p>

<p>Sources used:</p>

<ul>
  <li><a href="https://mechanical-sympathy.blogspot.com/2013/02/cpu-cache-flushing-fallacy.html">CPU Cache Flushing Fallacy, Mechanical Sympathy</a></li>
  <li><a href="https://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html">Memory Barriers/Fences, Mechanical Sympathy</a></li>
  <li><a href="http://www.javamex.com/tutorials/threads/thread_scheduling_java.shtml">Thread scheduling implications in Java, Javamex</a></li>
  <li><a href="http://www.javamex.com/tutorials/threads/context_switch.shtml">Context and process switching, Javamex</a></li>
  <li><a href="https://www.cs.cmu.edu/~fp/courses/15213-s06/lectures/27-multicore.pdf">Multi-core architectures, Carnegie Mellon University</a></li>
  <li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15418-s12/www/lectures/10_coherence.pdf">Lecture 10: Cache Coherence: Part I, Carnegie Mellon University</a></li>
  <li><a href="https://www.scss.tcd.ie/Jeremy.Jones/vivio/caches/MESIHelp.htm">MESI Cache Coherency Protocol, Trinity College Dublin, the University of Dublin, Ireland</a></li>
  <li><a href="http://web.cecs.pdx.edu/~alaa/ece587/notes/memory-ordering.pdf">Memory Ordering, Portland State University</a></li>
</ul>

<hr />

<p><a name="how-to-write-thread-safe-code"></a></p>
<h1 id="-how-to-write-thread-safe-code"><a href="#how-to-write-thread-safe-code">#</a> HOW TO WRITE THREAD-SAFE CODE?</h1>

<p>As previously discussed, the Java language offers many tools to help simplify the process of writing thread-safe code without needing to understand all the hardware details.</p>

<h4 id="the-synchronized-keyword">The <code class="highlighter-rouge">synchronized</code> Keyword</h4>

<p>One such tool is the <code class="highlighter-rouge">synchronized</code> keyword. All classes extending <code class="highlighter-rouge">Object</code> (basically classes that you write or are provided by the language excluding primitive types) possess what is known as an “intrinsic lock.” You can use a <code class="highlighter-rouge">synchronized</code> block to acquire the lock and release it when the block ends. The point of a lock is only one thread can “hold” the lock at any given time. This means that if <code class="highlighter-rouge">Thread A</code> already has the lock and <code class="highlighter-rouge">Thread B</code> arrives at the <code class="highlighter-rouge">synchronized</code> block, it will wait until <code class="highlighter-rouge">Thread A</code> is done before the lock can be acquired by <code class="highlighter-rouge">Thread B</code>. When more than one thread is waiting, a random thread is selected to acquire the lock once it is released. More on this later.</p>

<p>Consider the <code class="highlighter-rouge">MutableState</code> class from the previous section. We can utilize the <code class="highlighter-rouge">synchronized</code> keyword to ensure thread-safety like so:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ThreadSafe</span>
<span class="kd">class</span> <span class="nc">SafeMutableState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">++;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>I previously mentioned that the <code class="highlighter-rouge">synchronized</code> “block” is used to acquire and release a lock. However, in the above code snippet, I have used it as a method modifier. What’s going on? As a matter of fact, using the <code class="highlighter-rouge">synchronized</code> keyword as a method modifier is equivalent to the following:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ThreadSafe</span>
<span class="kd">class</span> <span class="nc">SafeMutableState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">()</span> <span class="o">{</span> 
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">++;</span> 
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span> 
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span> 
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A <code class="highlighter-rouge">synchronized</code> instance method means that it will simply wrap the method code with a <code class="highlighter-rouge">synchronized (this) {}</code> block. This acquires the intrinsic lock of the Object belonging to that instance of the class.</p>

<p>But what about <code class="highlighter-rouge">static</code> methods? Since we don’t have <code class="highlighter-rouge">this</code> access, which lock does the <code class="highlighter-rouge">synchronized</code> block acquire then? In that case, it would acquire the lock belonging to the <em>class object</em>. For example, say that there was a <code class="highlighter-rouge">static synchronized</code> method in <code class="highlighter-rouge">SafeMutableState</code>. That method would be equivalent to writing <code class="highlighter-rouge">synchronized (SafeMutableState.class) {}</code>.</p>

<p>By making the methods <code class="highlighter-rouge">synchronized</code>, we will ensure that only one thread can perform an increment operation at a time using the <code class="highlighter-rouge">mutate()</code> method. This means that the atomicity issue discussed in the earlier section, where one thread is in the middle of updating the <code class="highlighter-rouge">state</code> value doesn’t complete before another thread reads the value prior to the increment. The <code class="highlighter-rouge">mutate()</code> operation is therefore <em>atomic</em> because the operation completes in its entirety before it is called again. In effect, this means that the <code class="highlighter-rouge">mutate()</code> method is executed sequentially since each thread must line up if they try to update the <code class="highlighter-rouge">state</code> value simultaneously. Having threads line up in this way is sometimes referred to as <em>thread serialization</em>, (not to be confused with data serialization) because threads are executing serially (sequentially).</p>

<p>However, this doesn’t explain why the <code class="highlighter-rouge">read()</code> method is <code class="highlighter-rouge">synchronized</code> as well. Reading from a single field or writing to a single field (except in some cases involving the <code class="highlighter-rouge">long</code> and <code class="highlighter-rouge">double</code> types, more on this later) is atomic already, so we should have no issues, right? Actually, no, and the answer can even be “it depends.” That being said, the <em>only</em> safe and definitive way to ensure that <code class="highlighter-rouge">SafeMutableState</code> is thread-safe is to ensure that the <code class="highlighter-rouge">read()</code> method is synchronized. The main reason is visibility. A <code class="highlighter-rouge">synchronized</code> block only guarantees that <em>all</em> state values (even those that are not modified with a lock held) that are set BEFORE acquiring the lock are visible to the thread that acquires it. That means that even though we have a <code class="highlighter-rouge">synchronized mutate()</code> method, that only guarantees that the thread calling the <code class="highlighter-rouge">mutate()</code> method can see the <code class="highlighter-rouge">state</code> value. Therefore, in order to guarantee that changes made to the <code class="highlighter-rouge">state</code> value to be visible to the <code class="highlighter-rouge">read()</code> method, the <code class="highlighter-rouge">read()</code> method itself must also be <code class="highlighter-rouge">synchronized</code>. However, if we recall from the earlier section, the reason why we have visibility issues is because of the store and load buffers on the CPU. Therefore, as long as we have a fence inserted somewhere in our code, then all the most recent values will be available to the CPU already, which means that if we have a <code class="highlighter-rouge">synchronized</code> or <code class="highlighter-rouge">volatile</code> somewhere that would produce this fence, then we technically don’t even need the <code class="highlighter-rouge">synchronized</code> (we might not even need to synchronized on the same lock). Using side-effects like this is referred to as <em>piggybacking</em>. More on this later. With that, I only conclude that writing your code this way is <strong>dangerous</strong>, fragile, non-portable (especially on CPUs that do not have as strong guarantees about memory fences), and does not comply with the Java Language Specification. Remember, your code is either properly synchronized, or not synchronized at all. You cannot have half of your methods <code class="highlighter-rouge">synchronized</code>, and the other half not synchronized and expect your code to work correctly. Synchronize, and remember to synchronize on the correct locks to ensure that your code complies with the Java Memory Model.</p>

<p>Wherever your code is being called by multiple threads, a <code class="highlighter-rouge">synchronized</code> block can be used to ensure atomicity by allowing only a single thread to be executing that to ensure atomicity through thread serialization and that the state values read by that method are up to date.</p>

<p>One technical detail previously mentioned is that threads tend to be non-deterministic. There are many things that control thread timing and when threads run what - the OS thread scheduler and the CPU come to mind. The execution order of threads are arbitrary, and <code class="highlighter-rouge">synchronized</code> blocks cannot control that. When threads queue to wait for a lock, a random thread is selected when the lock becomes available again. It is possible to ensure FIFO order, but that requires a slightly different tool that I’ll be covering in a few sections. That being said, <code class="highlighter-rouge">synchronized</code> blocks can control reorderings to some extent. The compiler and the JIT may try to reorder certain instructions that work in single-threaded code, but will produce surprising results in multithreaded code. I myself don’t actually have any examples of this, but it is worth noting that the <code class="highlighter-rouge">synchronized</code> block cannot be reordered with other instructions outside the block as an optimization (although again, how this is an optimization I’m not exactly sure). A <code class="highlighter-rouge">synchronized</code> block acts as a kind of barrier for this, meaning that instructions cannot flow past the <code class="highlighter-rouge">synchronized</code> block; instructions before can be reordered still, but only as long as those instructions stay before the <code class="highlighter-rouge">synchronized</code> block. This is the same for instructions after the <code class="highlighter-rouge">synchronized</code> block and even instructions inside the <code class="highlighter-rouge">synchronized</code> block as well, so long as those instructions do not move outside of the <code class="highlighter-rouge">synchronized</code> block, of course.</p>

<h4 id="the-volatile-keyword">The <code class="highlighter-rouge">volatile</code> Keyword</h4>

<p>The <code class="highlighter-rouge">volatile</code> keyword, unlike <code class="highlighter-rouge">synchronized</code>, is a field modifier. While <code class="highlighter-rouge">synchronized</code> is designed to give strong guarantees for a block of code, <code class="highlighter-rouge">volatile</code> gives weaker guarantees for fields. Let’s take a look at how it is used:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NotThreadSafe</span>
<span class="kd">class</span> <span class="nc">VolatileMutableState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">++;</span> 
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In case you missed it, I’ll highlight again that the above snippet is <strong>not</strong> thread-safe. The only purpose of <code class="highlighter-rouge">volatile</code> is to ensure that state mutations are visible to other threads. However, because <code class="highlighter-rouge">volatile</code> has no impact on atomicity, <code class="highlighter-rouge">VolatileMutableState</code> is not thread-safe. Although the increment operation in <code class="highlighter-rouge">mutate()</code> will be visible to other threads, that only assumes that another thread doesn’t sneak in before the incremented value is set into the state. Remember, an increment operation is actually retrieving the state value and incrementing the local copy before updating the state. We ensure that the retrieval uses the most up-to-date value, and that other threads will see the update in the end, but visibility guarantees do not prevent another thread reading the state value before the update. In order to provide the atomicity guarantee, <code class="highlighter-rouge">synchronized</code> is needed because it allows for threads finish calling <code class="highlighter-rouge">mutate()</code> before passing off the lock to another thread.</p>

<p>However, if we don’t need to perform any non-atomic operations like an increment (these are usually called <em>compound operations</em> because they consist of multiple components) and we only need to hold a certain value, we can change the <code class="highlighter-rouge">VolatileMutableState</code> to look like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ThreadSafe</span>
<span class="kd">class</span> <span class="nc">VolatileStateHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mutate</span><span class="o">(</span><span class="kt">int</span> <span class="n">newState</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">state</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Since we have gotten rid of the atomicity issues, the class is now thread-safe. An additional guarantee that <code class="highlighter-rouge">volatile</code> provides is ordering, similar to how the <code class="highlighter-rouge">synchronized</code> keyword works. A volatile read or write acts sort of like a “fence,” which means that again, operations that occur before the volatile read or write cannot be reordered to occur after it, and operations after cannot be reordered to occur before the volatile read or write. Instructions can still be reordered, so long as they stay on their side of the fence. Recalling from the earlier section, this fence also works to ensure that reads and writes are completely seen by the CPU in order to provide visibility guarantees.</p>

<p>However, even though <code class="highlighter-rouge">VolatileStateHolder</code> is thread-safe, that doesn’t mean that anyone using it is safe as well. Consider the following use:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">VolatileStateHolder</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VolatileStateHolder</span><span class="o">();</span>

<span class="o">...</span>

<span class="c1">// WARNING: NOT THREAD SAFE</span>
<span class="kt">int</span> <span class="n">currentState</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">currentState</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The holder's state is still 0!"</span><span class="o">)</span>
    <span class="n">holder</span><span class="o">.</span><span class="na">mutate</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Can you spot the problem?</p>

<p>In this case, we have moved the atomicity problem we saw in the <code class="highlighter-rouge">VolatileMutableState</code> into the user code. If multiple threads were running the above snippet, then it is possible for <code class="highlighter-rouge">"The holder's state is still 0!"</code> to be printed multiple times. Again, notice how the state is retrieved, some operation occurs, and then the state is updated again. In this case, although the final state isn’t changing if multiple threads run, we still might not get the desired result. If another thread calls <code class="highlighter-rouge">holder.read()</code> before the another thread gets to <code class="highlighter-rouge">holder.mutate(1)</code>, then it will read <code class="highlighter-rouge">0</code> and re-run the code. In order to solve this problem, we need to synchronize:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">VolatileStateHolder</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VolatileStateHolder</span><span class="o">();</span>

<span class="o">...</span>

<span class="kd">synchronized</span> <span class="o">(</span><span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">currentState</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currentState</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The holder's state is still 0!"</span><span class="o">)</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">mutate</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, because we use a lock to prevent other threads from running the code concurrently, we have gotten rid of the atomicity problem. Although you might have written thread-safe classes, the way it is used by users may not be thread-safe.</p>

<p>While we are discussing the <code class="highlighter-rouge">synchronized</code> keyword for the moment, it is worth learning about what to actually synchronize on. In the previous section, I stated that all <code class="highlighter-rouge">Object</code>s have intrinsic locks. However, this doesn’t mean that you should synchronize on any odd <code class="highlighter-rouge">Object</code> you have on hand. In general, it is a good idea to reduce the scope of your locks, and prevent outside code from accessing them. Some programming adages suggest that you should avoid the <code class="highlighter-rouge">this</code> lock, because anyone who constructs your object now has access to its lock. However, sometimes, it is necessary to allow users to access that lock. For example, synchronized collections obtained from <code class="highlighter-rouge">Collections.synchronizedXYZ(...)</code> require that users synchronize on the collection if they want to iterate over it. This prevents other threads from modifying the collection while you are iterating over it. In this case, it is useful to use the <code class="highlighter-rouge">this</code> lock. Because the above example is user code, I decided to synchronize on the <code class="highlighter-rouge">holder</code> field, because the user would be in control of the scope of <code class="highlighter-rouge">holder</code>. Giving user code others access to a lock potentially could lead to someone accidentally synchronizing on it when it isn’t needed, which will prevent code that actually does need the lock to wait. While this slows down the application, it could also lead to more dire problems such as deadlock. If a class is full of primitive fields or is entirely mutable and <code class="highlighter-rouge">this</code> is the most obvious choice for a lock, an author will usually use a <code class="highlighter-rouge">private final Object lock = new Object();</code> and synchronize on that instead. Again, it is important that the same lock is used in order to ensure thread serialization, so a mutable lock is generally a poor idea. It is also possible to synchronize on local variables if it is associated with an object that is shared. So long as the code accessing the shared object uses the same lock, then there should be no issue. The key here is caution and defensive programming.</p>

<p>Back to the topic of <code class="highlighter-rouge">volatile</code> and having the knowledge of how to use it, what in the world could it be used for? While it is easy to see how a general-purpose/all-around tool like <code class="highlighter-rouge">synchronized</code> might be used, why would anyone ever use <code class="highlighter-rouge">volatile</code>? We see in the previous examples that we can use it for states that have a single value set or read by non-compound operations. If we never need to check on the state before we modify the state, then <code class="highlighter-rouge">volatile</code> is sufficient and no synchronization is needed. Remember, because field assignment and retrieval is atomic (except for <code class="highlighter-rouge">long</code>s and <code class="highlighter-rouge">double</code>s), we can use <code class="highlighter-rouge">volatile</code> to ensure thread-safety by making all changes visible. This is useful for things like loops that run until someone wants the loop to stop:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">isActive</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Another thread might want to stop the loop</span>
<span class="n">isActive</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<p>Another good use for <code class="highlighter-rouge">volatile</code> is ensuring that <code class="highlighter-rouge">long</code> and <code class="highlighter-rouge">double</code> states are atomically set. Because the Java Memory Model doesn’t guarantee that assignments to those types are atomic, marking them <code class="highlighter-rouge">volatile</code> will ensure that writes to them are atomic (however, this is the only atomicity guaranatee that <code class="highlighter-rouge">volatile</code> provides for). If you are worried about atomicity in the first place, you probably already need the state values to be visible anyways. Therefore, the fact that <code class="highlighter-rouge">volatile</code> assignment to <code class="highlighter-rouge">long</code> and <code class="highlighter-rouge">double</code> states is also atomic is just a nice side-effect in reality.</p>

<p>One niche use of <code class="highlighter-rouge">volatile</code> is for single-writer thread models. This means that only one thread does mutations, while all other threads simply read the state. So, while <code class="highlighter-rouge">VolatileMutableState</code> is not actually thread-safe for multiple mutator threads, if we impose a policy that allows only one thread to ever call <code class="highlighter-rouge">mutate()</code>, then we have solved the atomicity problem. No other threads can possibly interfere with the increment. We have an external policy that ensures atomicity and we use <code class="highlighter-rouge">volatile</code> to ensure visibility and ordering. Therefore, the threading model you use can allow you to use non thread-safe classes in a way that is nonetheless thread-safe.</p>

<p><code class="highlighter-rouge">// TODO</code></p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Inside a Troll</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Inside a Troll
            
            </li>
            
            <li><a href="mailto:woodyc40@gmail.com">woodyc40@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/AgentTroll"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">AgentTroll</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/AgentTrolldude"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">AgentTrolldude</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Thoughts of a Java developer</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
